# image_storage

Near manage.py   
```redis-server``` - to run redis server
```celery -A images_storage worker -l info``` - to run worker
```celery purge -A images_storage``` - clean queue


```python manage.py createsuperuser``` - create superuser django

```heroku ps:scale worker=1```
```heroku ps:scale web=1```




#### **Work with GIT**

Создание ветви функциональности (feature branch)

При начале работы над новой функциональностью делается ответвление от ветви разработки (develop).

```$ git checkout -b myfeature develop``` - 
Switched to a new branch "myfeature"

Добавление завершённой функциональности в develop

Завершённая функциональность (фича) вливается обратно в ветвь разработки (develop) и попадает в следующий релиз.

```$ git checkout develop``` -
Switched to branch 'develop'

```$ git merge --no-ff myfeature``` - 
Updating ea1b82a..05e9557
(Отчёт об изменениях)

```$ git branch -d myfeature``` - 
Deleted branch myfeature (was 05e9557).
$ git push origin develop

Флаг --no-ff вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и группирует вместе все внесённые изменения. Сравните:



Во втором случае невозможно увидеть в истории изменений, какие именно объекты коммитов совместно образуют функциональность, — для этого придётся вручную читать все сообщения в коммитах. Отменить функциональность целиком (т.е., группу коммитов) в таком случае невозможно без головной боли, а с флагом --no-ff это делается элементарно.

Конечно, такой подход создаёт некоторое дополнительное количество (пустых) объектов коммитов, но получаемая выгода более чем оправдывает подобную цену.

К сожалению, я ещё не нашёл, как можно настроить Git так, чтобы --no-ff было поведением по-умолчанию при слияниях. Но этот способ должен быть реализован.'''